var l=Object.defineProperty;var d=(s,e,t)=>e in s?l(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t;var o=(s,e,t)=>d(s,typeof e!="symbol"?e+"":e,t);class h{constructor(e){o(this,"engine");o(this,"status","unloaded");o(this,"statusListeners",new Set);o(this,"config");this.config=e}getStatus(){return this.status}isReady(){return this.status==="ready"}isCompiling(){return this.status==="compiling"}addStatusListener(e){return this.statusListeners.add(e),()=>this.statusListeners.delete(e)}notifyStatusChange(){this.statusListeners.forEach(e=>e())}setStatus(e){this.status=e,this.notifyStatusChange()}async initialize(){if(this.status!=="ready"){if(this.status==="loading")return new Promise((e,t)=>{const r=()=>{this.status==="ready"?e():this.status==="error"?t(new Error(`Failed to initialize ${this.config.name} engine`)):setTimeout(r,100)};r()});this.setStatus("loading");try{await this.loadScripts(),this.engine=this.createEngine(),await this.engine.loadEngine(),this.setStatus("ready")}catch(e){throw this.setStatus("error"),e}}}async reinitialize(){this.cleanup(),await this.initialize()}cleanup(){if(this.engine){try{this.engine.closeWorker()}catch(e){console.warn("Error during engine cleanup:",e)}this.engine=void 0}this.setStatus("unloaded")}stopCompilation(){if(this.isCompiling()&&this.engine)try{this.engine.closeWorker(),this.setStatus("error"),this.status="ready"}catch(e){console.warn("Error stopping compilation:",e)}}}const n=class n{static async loadScript(e){return n.loadedScripts.has(e)?Promise.resolve():new Promise((t,r)=>{const a=document.createElement("script");a.src=e,a.onload=()=>{n.loadedScripts.add(e),t()},a.onerror=i=>{r(new Error(`Failed to load script: ${e}`))},document.head.appendChild(a)})}static async loadScripts(e){for(const t of e)await n.loadScript(t)}static isScriptLoaded(e){return n.loadedScripts.has(e)}static removeScript(e){const t=document.querySelector(`script[src="${e}"]`);t&&(t.remove(),n.loadedScripts.delete(e))}};o(n,"loadedScripts",new Set);let c=n;class g extends h{constructor(){const e={name:"XeTeX",setupScript:"/core/swiftlatex/TexlyreXeTeXEngineSetup.js",engineScript:"/core/swiftlatex/texlyrexetex.js",engineClass:"XeTeXEngine"};super(e)}async loadScripts(){if(typeof window.XeTeXEngine!="function"&&(await c.loadScripts([this.config.setupScript,this.config.engineScript]),typeof window.XeTeXEngine!="function"))throw new Error("XeTeXEngine not available after loading scripts")}createEngine(){return new window.XeTeXEngine}setTexliveEndpoint(e){this.engine.setTexliveEndpoint(e),console.log(`[XeTeXEngine] TexLive endpoint set for XeTeX: ${e}`)}writeMemFSFile(e,t){if(!this.engine)throw new Error("Engine not initialized");this.engine.writeMemFSFile(e,t)}makeMemFSFolder(e){if(!this.engine)throw new Error("Engine not initialized");this.engine.makeMemFSFolder(e)}setEngineMainFile(e){if(!this.engine)throw new Error("Engine not initialized");this.engine.setEngineMainFile(e)}flushCache(){if(!this.engine)throw new Error("Engine not initialized");this.engine.flushCache()}async dumpDirectory(e){if(!this.engine)throw new Error("Engine not initialized");return await this.engine.dumpDirectory(e)}async compile(e,t){var r,a;if(!this.engine||!this.isReady())throw new Error("Engine not ready");this.setStatus("compiling");try{await this.engine.compileLaTeX(),await this.engine.compileLaTeX();const i=await this.engine.compileLaTeX();return this.setStatus("ready"),console.log("[XeTeXEngine] XeTeX compilation result:",{status:i.status,hasPdf:!!i.pdf,hasXdv:!!i.xdv,pdfSize:(r=i.pdf)==null?void 0:r.length,xdvSize:(a=i.xdv)==null?void 0:a.length}),i.status===0&&i.pdf?{pdf:void 0,status:i.status,log:i.log,xdv:i.pdf}:{pdf:i.pdf,status:i.status,log:i.log}}catch(i){throw this.flushCache(),this.setStatus("error"),i}}}export{g as XeTeXEngine};
//# sourceMappingURL=XeTeXEngine-BTxOmehr.js.map
