{"version":3,"file":"TypstCompilerEngine-pRJlCa9l.js","sources":["../../node_modules/nanoid/url-alphabet/index.js","../../node_modules/nanoid/index.browser.js","../../src/engines/TypstCompilerEngine.ts"],"sourcesContent":["export const urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\n","/* @ts-self-types=\"./index.d.ts\" */\nimport { urlAlphabet as scopedUrlAlphabet } from './url-alphabet/index.js'\nexport { urlAlphabet } from './url-alphabet/index.js'\nexport let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))\nexport let customRandom = (alphabet, defaultSize, getRandom) => {\n  let mask = (2 << Math.log2(alphabet.length - 1)) - 1\n  let step = -~((1.6 * mask * defaultSize) / alphabet.length)\n  return (size = defaultSize) => {\n    let id = ''\n    while (true) {\n      let bytes = getRandom(step)\n      let j = step | 0\n      while (j--) {\n        id += alphabet[bytes[j] & mask] || ''\n        if (id.length >= size) return id\n      }\n    }\n  }\n}\nexport let customAlphabet = (alphabet, size = 21) =>\n  customRandom(alphabet, size | 0, random)\nexport let nanoid = (size = 21) => {\n  let id = ''\n  let bytes = crypto.getRandomValues(new Uint8Array((size |= 0)))\n  while (size--) {\n    id += scopedUrlAlphabet[bytes[size] & 63]\n  }\n  return id\n}\n","// src/engines/TypstCompilerEngine.ts\nimport { nanoid } from 'nanoid';\n\n// Re-defining types inline to avoid dependency compilation issues if shared types are missing\nexport interface TypstPdfOptions {\n    // Add options as needed\n}\n\nexport type TypstWorkerMessage =\n    | { id: string; type: 'compile'; payload: { mainFilePath: string; sources: Record<string, string | Uint8Array>; format: 'pdf' | 'svg' | 'canvas'; pdfOptions?: TypstPdfOptions } }\n    | { id: string; type: 'ping' };\n\nexport type TypstWorkerResponse =\n    | { id: string; type: 'pong' }\n    | { id: string; type: 'done'; result: { format: string; output: Uint8Array | string; diagnostics?: any[] } }\n    | { id: string; type: 'error'; error: string };\n\nexport class TypstCompilerEngine {\n    private worker: Worker | null = null;\n    private pendingResolves: Map<string, (v: any) => void> = new Map();\n    private pendingRejects: Map<string, (e: any) => void> = new Map();\n\n    getWorker(): Worker {\n        if (this.worker) return this.worker;\n\n        // Path to worker needs to be correct relative to where this file is imported or built\n        // Since we are in src/engines, and worker will be in src/workers or similar?\n        // Let's place the worker in src/workers/typst.worker.ts and reference it\n        // Vite handles this well usually.\n        this.worker = new Worker(new URL('../workers/typst.worker.ts', import.meta.url), {\n            type: 'module',\n        });\n\n        this.worker.onmessage = (e: MessageEvent<TypstWorkerResponse>) => {\n            const { id, type } = e.data;\n\n            if (!id) return;\n\n            if (type === 'done' || type === 'pong') {\n                const resolve = this.pendingResolves.get(id);\n                if (resolve) resolve('result' in e.data ? e.data.result : undefined);\n            } else if (type === 'error') {\n                const reject = this.pendingRejects.get(id);\n                if (reject) reject(new Error(e.data.error || 'Worker error'));\n            }\n\n            this.pendingResolves.delete(id);\n            this.pendingRejects.delete(id);\n        };\n\n        this.worker.onerror = (ev) => {\n            const err = new Error(`Typst worker error: ${String(ev.message || ev)}`);\n            this.pendingRejects.forEach((reject) => reject(err));\n            this.pendingResolves.clear();\n            this.pendingRejects.clear();\n            this.worker = null;\n        };\n\n        return this.worker;\n    }\n\n    async ping(): Promise<void> {\n        return this.callWorker('ping', undefined);\n    }\n\n    async compile(\n        mainFilePath: string,\n        sources: Record<string, string | Uint8Array>,\n        format: 'pdf' | 'svg' | 'canvas',\n        pdfOptions?: TypstPdfOptions,\n        signal?: AbortSignal\n    ): Promise<{ format: string; output: Uint8Array | string; diagnostics?: any[] }> {\n        return this.callWorker('compile', { mainFilePath, sources, format, pdfOptions }, signal);\n    }\n\n    terminate(): void {\n        if (this.worker) {\n            this.worker.terminate();\n            this.worker = null;\n        }\n        this.pendingResolves.clear();\n        this.pendingRejects.clear();\n    }\n\n    private callWorker<TType extends 'compile' | 'ping'>(\n        type: TType,\n        payload: TType extends 'compile'\n            ? { mainFilePath: string; sources: Record<string, string | Uint8Array>; format: 'pdf' | 'svg' | 'canvas'; pdfOptions?: TypstPdfOptions }\n            : undefined,\n        signal?: AbortSignal\n    ): Promise<any> {\n        const id = nanoid();\n        const worker = this.getWorker();\n\n        const promise = new Promise((resolve, reject) => {\n            this.pendingResolves.set(id, resolve);\n            this.pendingRejects.set(id, reject);\n        });\n\n        const abort = () => {\n            if (this.worker) {\n                this.worker.terminate();\n                this.worker = null;\n            }\n            const reject = this.pendingRejects.get(id);\n            if (reject) reject(new Error('Compilation was cancelled'));\n            this.pendingResolves.delete(id);\n            this.pendingRejects.delete(id);\n        };\n\n        if (signal) {\n            if (signal.aborted) {\n                abort();\n                return Promise.reject(new Error('Compilation was cancelled'));\n            }\n            signal.addEventListener('abort', abort, { once: true });\n        }\n\n        worker.postMessage({ id, type, payload });\n\n        return promise;\n    }\n}\n"],"names":["urlAlphabet","nanoid","size","id","bytes","scopedUrlAlphabet","TypstCompilerEngine","__publicField","type","resolve","reject","ev","err","mainFilePath","sources","format","pdfOptions","signal","payload","worker","promise","abort"],"mappings":"oKAAO,MAAMA,EACX,mECoBK,IAAIC,EAAS,CAACC,EAAO,KAAO,CACjC,IAAIC,EAAK,GACLC,EAAQ,OAAO,gBAAgB,IAAI,WAAYF,GAAQ,CAAC,CAAE,EAC9D,KAAOA,KACLC,GAAME,EAAkBD,EAAMF,CAAI,EAAI,EAAE,EAE1C,OAAOC,CACT,ECXO,MAAMG,CAAoB,CAA1B,cACKC,EAAA,cAAwB,MACxBA,EAAA,2BAAqD,KACrDA,EAAA,0BAAoD,KAE5D,WAAoB,CAChB,OAAI,KAAK,OAAe,KAAK,QAM7B,KAAK,OAAS,IAAI,OAAO,IAAA,IAAA,mCAAA,YAAA,GAAA,EAAwD,CAC7E,KAAM,QAAA,CACT,EAED,KAAK,OAAO,UAAa,GAAyC,CAC9D,KAAM,CAAE,GAAAJ,EAAI,KAAAK,CAAA,EAAS,EAAE,KAEvB,GAAKL,EAEL,IAAIK,IAAS,QAAUA,IAAS,OAAQ,CACpC,MAAMC,EAAU,KAAK,gBAAgB,IAAIN,CAAE,EACvCM,KAAiB,WAAY,EAAE,KAAO,EAAE,KAAK,OAAS,MAAS,CACvE,SAAWD,IAAS,QAAS,CACzB,MAAME,EAAS,KAAK,eAAe,IAAIP,CAAE,EACrCO,KAAe,IAAI,MAAM,EAAE,KAAK,OAAS,cAAc,CAAC,CAChE,CAEA,KAAK,gBAAgB,OAAOP,CAAE,EAC9B,KAAK,eAAe,OAAOA,CAAE,EACjC,EAEA,KAAK,OAAO,QAAWQ,GAAO,CAC1B,MAAMC,EAAM,IAAI,MAAM,uBAAuB,OAAOD,EAAG,SAAWA,CAAE,CAAC,EAAE,EACvE,KAAK,eAAe,QAASD,GAAWA,EAAOE,CAAG,CAAC,EACnD,KAAK,gBAAgB,MAAA,EACrB,KAAK,eAAe,MAAA,EACpB,KAAK,OAAS,IAClB,EAEO,KAAK,OAChB,CAEA,MAAM,MAAsB,CACxB,OAAO,KAAK,WAAW,OAAQ,MAAS,CAC5C,CAEA,MAAM,QACFC,EACAC,EACAC,EACAC,EACAC,EAC6E,CAC7E,OAAO,KAAK,WAAW,UAAW,CAAE,aAAAJ,EAAc,QAAAC,EAAS,OAAAC,EAAQ,WAAAC,CAAA,EAAcC,CAAM,CAC3F,CAEA,WAAkB,CACV,KAAK,SACL,KAAK,OAAO,UAAA,EACZ,KAAK,OAAS,MAElB,KAAK,gBAAgB,MAAA,EACrB,KAAK,eAAe,MAAA,CACxB,CAEQ,WACJT,EACAU,EAGAD,EACY,CACZ,MAAMd,EAAKF,EAAA,EACLkB,EAAS,KAAK,UAAA,EAEdC,EAAU,IAAI,QAAQ,CAACX,EAASC,IAAW,CAC7C,KAAK,gBAAgB,IAAIP,EAAIM,CAAO,EACpC,KAAK,eAAe,IAAIN,EAAIO,CAAM,CACtC,CAAC,EAEKW,EAAQ,IAAM,CACZ,KAAK,SACL,KAAK,OAAO,UAAA,EACZ,KAAK,OAAS,MAElB,MAAMX,EAAS,KAAK,eAAe,IAAIP,CAAE,EACrCO,GAAQA,EAAO,IAAI,MAAM,2BAA2B,CAAC,EACzD,KAAK,gBAAgB,OAAOP,CAAE,EAC9B,KAAK,eAAe,OAAOA,CAAE,CACjC,EAEA,GAAIc,EAAQ,CACR,GAAIA,EAAO,QACP,OAAAI,EAAA,EACO,QAAQ,OAAO,IAAI,MAAM,2BAA2B,CAAC,EAEhEJ,EAAO,iBAAiB,QAASI,EAAO,CAAE,KAAM,GAAM,CAC1D,CAEA,OAAAF,EAAO,YAAY,CAAE,GAAAhB,EAAI,KAAAK,EAAM,QAAAU,EAAS,EAEjCE,CACX,CACJ","x_google_ignoreList":[0,1]}